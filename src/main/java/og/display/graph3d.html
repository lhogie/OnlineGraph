<!DOCTYPE html>
<html lang="en">

<head>
  <style>
    body {
      margin: 0;
    }
  </style>
  <title>3D Graph visualizer</title>
  <script src="//unpkg.com/3d-force-graph"></script>
  <script src="//unpkg.com/d3-octree"></script>
  <script src="//unpkg.com/d3-force-3d"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.3/jquery.min.js"></script>
</head>

<body>
  <div id="3d-graph"></div>

  <script>

    let Graph;
    let init = []
    //.linkOpacity(0.5);

    var jqxhr = $.getJSON("./graph.json", function (data) {
      
      data["vertices"].forEach(vertex => {

        init.push({
            id: vertex["id"],
            vx: Math.random(),
            vy: Math.random(),
            vz: Math.random()
          });
        });
     
        console.log(init);
      Graph = ForceGraph3D()
      (document.getElementById('3d-graph'))
      .linkColor(() => 'rgba(255, 255, 255, 1)')
      .linkWidth(1);


    console.log(init);
    Graph.onEngineTick(() => {
      const { nodes, links } = Graph.graphData();

      // If the distance between two nodes < D, add a link
      const D = 100;
      for (let i = 0; i < nodes.length; i++) {
        for (let j = i + 1; j < nodes.length; j++) {
          const dx = Math.abs(nodes[i].x - nodes[j].x);
          const dy = Math.abs(nodes[i].y - nodes[j].y);
          const dz = Math.abs(nodes[i].z - nodes[j].z);
          const dist = dx + dy + dz;
          const linkIdx = links.findIndex(l => l.source === nodes[i] && l.target === nodes[j]);
          const link = links[linkIdx];

          if (dist < D && linkIdx === -1) {
            Graph.graphData({
              nodes: [...nodes],
              links: [...links, { source: nodes[i], target: nodes[j] }]
            });

          } else if (dist > D && linkIdx !== -1) {
            // Find current link and remove it
            if (linkIdx !== -1) {
              links.splice(linkIdx, 1);
              Graph.graphData({ nodes, links });
            }
          }
        }
      }
    });

    Graph.cooldownTime(Infinity)
      .d3AlphaDecay(0)
      .d3VelocityDecay(0)

      // Deactivate existing forces
      .d3Force('center', null)
      .d3Force('charge', null)
      .d3Force('link', null)

      // Add collision and bounding box forces
      .d3Force('collide', d3.forceCollide(Graph.nodeRelSize()))
      .d3Force('box', () => {
        const { nodes, links } = Graph.graphData();
        const CUBE_HALF_SIDE = Graph.nodeRelSize() * 20 * 0.5;

        nodes.forEach(node => {
          const x = node.x || 0, y = node.y || 0, z = node.z || 0;

          // bounce on box walls
          if (Math.abs(x) > CUBE_HALF_SIDE) { node.vx *= -1; }
          if (Math.abs(y) > CUBE_HALF_SIDE) { node.vy *= -1; }
          if (Math.abs(z) > CUBE_HALF_SIDE) { node.vz *= -1; }
        });
      })

      // Add nodes
      .graphData({ nodes: init, links: [] });
    
    });


  </script>
</body>

</html>